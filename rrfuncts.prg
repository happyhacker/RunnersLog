
* Program generated by R&R Relational Report Writer Code Generator, Version 1.1
****************************************************
PROCEDURE rr_cwrap
PARAMETERS lc_string, ln_width, ln_windex, ln_format
* next wrapped character field
****************************************************
PRIVATE lc_f, lc_s, ln_l, ln_k, ll_full
DO WHILE .T.
	* check if field is empty
	IF Mwrap[m->ln_windex] > LEN(m->lc_string)
		Mwrap[m->ln_windex+1] = ''
		Mwrap[m->ln_windex+2] = .F.
		Mwrap[m->ln_windex+3] = ''
		RETURN
	ENDIF
	* ignore leading spaces if last line wrapped
	IF LEN(Mwrap[m->ln_windex+3]) = 0 .OR. SUBSTR(m->lc_string,Mwrap[;
		m->ln_windex],1) <> ' '
		EXIT
	ENDIF
	Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + 1
ENDDO
* extract full width string
lc_f = SUBSTR(m->lc_string,Mwrap[m->ln_windex],m->ln_width+1)
ln_l = LEN(m->lc_f)
* treat semi-colon as line terminator
ln_k = AT(';',m->lc_f)
* remember whether line is wrapping or not
ll_full = m->ln_k = 0 .AND. m->ln_l > m->ln_width
Mwrap[m->ln_windex+3] = IIF(m->ll_full,';','')
* find line ending
IF m->ln_k = 0
	IF m->ln_l <= m->ln_width
		lc_f = m->lc_f + ' '
		ln_l = m->ln_l + 1
	ENDIF
	ln_k = m->ln_l - 1
	DO WHILE .T.
		* wrap before space
		IF SUBSTR(m->lc_f,m->ln_k+1,1) = ' '
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k + 1
			EXIT
		ENDIF
		* wrap after hypen, if it's part of a word
		IF SUBSTR(m->lc_f,m->ln_k+1,1) = '-' .AND. SUBSTR(m->lc_f,m->ln_k,1) ;
			<> ' ' .AND. SUBSTR(m->lc_f,m->ln_k,1) <> '('
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k + 1
			ln_k = m->ln_k + 1
			EXIT
		ENDIF
		ln_k = m->ln_k - 1
		IF m->ln_k = 0
			ln_k = m->ln_l - 1
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k
			EXIT
		ENDIF
	ENDDO
ELSE
	* discard semi-colon
	Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k
	ln_k = m->ln_k - 1
ENDIF
lc_f = RTRIM(LEFT(m->lc_f,m->ln_k))
ln_k = LEN(m->lc_f)
DO CASE
	CASE m->ln_format = 0
	* left justify
	CASE m->ln_format = 1
	* full justify
		lc_s = ''
		DO WHILE m->ll_full .AND. m->ln_k < m->ln_width
			* find next space in lc_f
			ln_l = AT(' ',m->lc_f)
			IF m->ln_l = 0
				IF LEN(m->lc_s) = 0
					EXIT
				ENDIF
				* if lc_f exhausted of spaces, copy lc_s back and retry
				lc_f = m->lc_s + m->lc_f
				lc_s = ''
				LOOP
			ENDIF
			* append up to and including first space to lc_s
			lc_s = m->lc_s + LEFT(m->lc_f,m->ln_l)
			lc_f = SUBSTR(m->lc_f,m->ln_l+1)
			* also append all leading spaces of lc_f
			DO WHILE AT(' ',m->lc_f)=1
				lc_s = m->lc_s + ' '
				lc_f = SUBSTR(m->lc_f,2)
			ENDDO
			* then insert a new space at end of lc_s
			lc_s = m->lc_s + ' '
			ln_k = m->ln_k + 1
		ENDDO
		lc_f = m->lc_s + m->lc_f
	CASE m->ln_format = 2
	* right justify
		lc_f = SPACE(m->ln_width - m->ln_k) + m->lc_f
	ENDCASE
Mwrap[m->ln_windex + 1] = m->lc_f
Mwrap[m->ln_windex+2] = .T.
RETURN

**********************************************
PROCEDURE rr_mfield
PARAMETERS lc_name, ln_windex, ln_k
* replace data names with values in memo field
**********************************************
PRIVATE lc_field, lc_edit, ln_n, ln_j
ln_n = AT('\',SUBSTR(Mwrap[m->ln_windex+1],m->ln_k+1))
DO CASE
	CASE m->ln_n > 0
		lc_field = SUBSTR(Mwrap[m->ln_windex+1],m->ln_k+1,m->ln_n-1)
		ln_j = 0
	OTHERWISE
		ln_j = AT('\',SUBSTR(&lc_name,Mwrap[m->ln_windex]))
		IF m->ln_j = 0 .OR. m->ln_j >20
			RETURN
		ENDIF
		lc_field = SUBSTR(Mwrap[m->ln_windex+1],m->ln_k+1) + SUBSTR(&lc_name,;
			Mwrap[m->ln_windex], m->ln_j-1)
ENDCASE
lc_edit = ''
DO &gc_memx WITH lc_edit, m->lc_field
IF LEN(m->lc_edit) = 0
	RETURN
ENDIF
lc_edit = LTRIM(RTRIM(m->lc_edit))
IF m->ln_j = 0
	Mwrap[m->ln_windex] = Mwrap[m->ln_windex] - (LEN(Mwrap[m->ln_windex+1]) - ;
		(m->ln_k + m->ln_n))
ELSE
	Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_j
ENDIF
Mwrap[m->ln_windex+3] = LEFT(Mwrap[m->ln_windex+1],m->ln_k-1) + m->lc_edit
Mwrap[m->ln_windex+1] = ''
RETURN

***********************************
PROCEDURE rr_mget
PARAMETERS lc_name, ln_windex, ln_n
* get n bytes from memo field
***********************************
PRIVATE ln_k, ln_m
IF Mwrap[m->ln_windex] > LEN(&lc_name) .AND. LEN(Mwrap[m->ln_windex+3]) = 0
	Mwrap[m->ln_windex+1] =  ''
	RETURN
ENDIF
DO WHILE .T.
	ln_k = LEN(Mwrap[m->ln_windex+3])
	DO CASE
		CASE m->ln_k = 0
			Mwrap[m->ln_windex+1] = SUBSTR(&lc_name,Mwrap[m->ln_windex],m->ln_n)
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + LEN(MWrap[;
				m->ln_windex+1])
			ln_m = AT('\',Mwrap[m->ln_windex+1])
			IF m->ln_m > 0
				DO rr_mfield WITH m->lc_name, m->ln_windex, m->ln_m
				IF LEN(Mwrap[m->ln_windex+1]) = 0
					LOOP
				ENDIF
			ENDIF
			RETURN
		CASE m->ln_k >= m->ln_n
			Mwrap[m->ln_windex+1] = LEFT(Mwrap[m->ln_windex+3],m->ln_n)
			Mwrap[m->ln_windex+3] = SUBSTR(Mwrap[m->ln_windex+3],m->ln_n+1)
			RETURN
		OTHERWISE
			Mwrap[m->ln_windex+1] = Mwrap[m->ln_windex+3]
			Mwrap[m->ln_windex+3] = SUBSTR(&lc_name,Mwrap[m->ln_windex],;
				m->ln_n - m->ln_k)
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + LEN(Mwrap[;
				m->ln_windex+3])
			Mwrap[m->ln_windex+1] = Mwrap[m->ln_windex+1] + Mwrap[;
				m->ln_windex+3]
			Mwrap[m->ln_windex+3] = ''
			ln_m = AT('\',SUBSTR(Mwrap[m->ln_windex+1],m->ln_k+1))
			IF m->ln_m > 0
				DO rr_mfield WITH m->lc_name, m->ln_windex, m->ln_k + m->ln_m
				IF LEN(Mwrap[m->ln_windex+1]) = 0
					LOOP
				ENDIF
			ENDIF
			RETURN
	ENDCASE
ENDDO

************************************************
PROCEDURE rr_mwrap
PARAMETERS lc_id, ln_width, ln_windex, ln_format
* next wrapped memo field
************************************************
PRIVATE ln_area, ln_rno, lc_name, lc_f, lc_s, ln_l, ln_k, ll_full
ln_area = VAL(m->lc_id)
ln_rno = VAL(SUBSTR(m->lc_id,AT('/',m->lc_id) + 1))
lc_name = SUBSTR(m->lc_id,AT(':',m->lc_id) + 1)
* position to correct dbf record
ln_rno = rr_go_rec(m->ln_area,m->ln_rno)
* extract string of length width plus one
DO rr_mget WITH m->lc_name, m->ln_windex, m->ln_width+1
lc_f = Mwrap[m->ln_windex+1]
ln_l = LEN(m->lc_f)
* test for end of memo field
IF m->ln_l = 0
	Mwrap[m->ln_windex+1] = ''
	Mwrap[m->ln_windex+2] = .F.
	ln_rno = rr_go_rec(m->ln_area,m->ln_rno)
	RETURN
ENDIF
DO WHILE .T.
	ln_l = LEN(m->lc_f)
	* look for newline
	ln_k = AT(CHR(10),m->lc_f)
	DO CASE
		* 'soft' return?
		CASE m->ln_k > 1 .AND. SUBSTR(m->lc_f,m->ln_k-1,1) = CHR(141)
			IF m->ln_k = 2 .OR. (m->ln_k > 2 .AND. SUBSTR(m->lc_f,m->ln_k-2,1);
				 = ' ')
				DO rr_mget WITH m->lc_name, m->ln_windex, 2
				lc_f = LEFT(m->lc_f,m->ln_k-2) + SUBSTR(m->lc_f,m->ln_k+1) + ;
					Mwrap[m->ln_windex+1]
			ELSE
				DO rr_mget WITH m->lc_name, m->ln_windex, 1
				lc_f = LEFT(m->lc_f,m->ln_k-2) + ' ' + SUBSTR(m->lc_f,m->ln_k+;
					1) + Mwrap[m->ln_windex+1]
			ENDIF
			LOOP
		* hard return
		CASE m->ln_k > 0
			Mwrap[m->ln_windex+3] = SUBSTR(m->lc_f,m->ln_k+1) + Mwrap[;
				m->ln_windex+3]
			lc_f = rr_mfilt(RTRIM(LEFT(m->lc_f,m->ln_k-1)))
			ll_full = .F.
			IF LEN(m->lc_f) = m->ln_width
				Mwrap[m->ln_windex+3] = CHR(10) + Mwrap[m->ln_windex+3]
			ENDIF
			EXIT
		* last line in memo field
		CASE m->ln_l <= m->ln_width
			lc_f = rr_mfilt(RTRIM(m->lc_f))
			ll_full = .F.
			EXIT
		* full-width line, so far
		OTHERWISE
			lc_f = rr_mfilt(m->lc_f)
			ln_k = LEN(m->lc_f)
			IF m->ln_k < m->ln_l
				DO rr_mget WITH m->lc_name, m->ln_windex, m->ln_l - m->ln_k
				lc_f = m->lc_f + Mwrap[m->ln_windex+1]
				LOOP
			ENDIF
			ll_full = .T.
			ln_k = m->ln_width
			* find last space in line
			IF SUBSTR(m->lc_f,m->ln_k+1,1) = ' '
				lc_f = RTRIM(m->lc_f)
				EXIT
			ENDIF
			DO WHILE .T.
				IF SUBSTR(m->lc_f,m->ln_k,1) = ' '
					Mwrap[m->ln_windex+3] = SUBSTR(m->lc_f,m->ln_k+1) + Mwrap[;
						m->ln_windex+3]
					lc_f = RTRIM(LEFT(m->lc_f,m->ln_k-1))
					EXIT
				ENDIF
				* wrap after hypen, if it's part of a word
				IF SUBSTR(m->lc_f,m->ln_k,1) = '-' .AND. m->ln_k > 1 .AND. ;
					SUBSTR(m->lc_f,m->ln_k-1,1) <> ' ' .AND. SUBSTR(m->lc_f,;
					m->ln_k-1,1) <> '('
					Mwrap[m->ln_windex+3] = SUBSTR(m->lc_f,m->ln_k+1) + Mwrap[;
						m->ln_windex+3]
					lc_f = RTRIM(LEFT(m->lc_f,m->ln_k))
					EXIT
				ENDIF
				ln_k = m->ln_k - 1
				* if no spaces, take full width
				IF m->ln_k = 0
					Mwrap[m->ln_windex+3] = RIGHT(m->lc_f,1) + Mwrap[;
						m->ln_windex+3]
					lc_f = LEFT(m->lc_f,m->ln_width)
					EXIT
				ENDIF
			ENDDO
			lc_f = RTRIM(m->lc_f)
			EXIT
	ENDCASE
ENDDO
ln_k = LEN(m->lc_f)
* justify string
DO CASE
	* left justify
	CASE m->ln_format = 0
	* full justify
	CASE m->ln_format = 1
		lc_s = ''
		DO WHILE m->ll_full .AND. m->ln_k < m->ln_width
			* find next space in lc_f
			ln_l = AT(' ',m->lc_f)
			IF m->ln_l = 0
				IF LEN(m->lc_s) = 0
					EXIT
				ENDIF
				* if lc_f exhausted of spaces, copy lc_s back and retry
				lc_f = m->lc_s + m->lc_f
				lc_s = ''
				LOOP
			ENDIF
			* append up to and including first space to lc_s
			lc_s = m->lc_s + LEFT(m->lc_f,m->ln_l)
			lc_f = SUBSTR(m->lc_f,m->ln_l+1)
			* also append all leading spaces of lc_f
			DO WHILE AT(' ',m->lc_f)=1
				lc_s = m->lc_s + ' '
				lc_f = SUBSTR(m->lc_f,2)
			ENDDO
			* then insert a new space at end of lc_s
			lc_s = m->lc_s + ' '
			ln_k = m->ln_k + 1
		ENDDO
		lc_f = m->lc_s + m->lc_f
	* right justify
	CASE m->ln_format = 2
		lc_f = SPACE(m->ln_width - m->ln_k) + m->lc_f
	* center justify
	CASE m->ln_format = 3
		lc_f = SPACE((m->ln_width - m->ln_k)/2) + m->lc_f
	ENDCASE
Mwrap[m->ln_windex + 1] = m->lc_f
Mwrap[m->ln_windex+2] = .T.
ln_rno = rr_go_rec(m->ln_area,m->ln_rno)
RETURN

********************
PROCEDURE rr_outf
PARAMETERS lc_string
* output string
********************
PRIVATE ln_l
ln_l = LEN(m->lc_string)
* ignore null string
IF m->ln_l = 0
	RETURN
ENDIF
* if the line is blank so far
IF m->gl_blank
	* and these are more spaces
	IF LEN(TRIM(m->lc_string)) = 0
		* update the column position and exit
		gn_outcol = m->gn_outcol + m->ln_l
		RETURN
	* first non-blank data on line - space over to it
	ELSE
		* if we're on or after starting page
		IF m->gn_pno >= m->gn_startpg
			IF m->gc_dest <> 'D'
				?? SPACE(m->gn_indent)
			ENDIF
			?? SPACE(m->gn_outcol)
		ENDIF
		gl_blank = .F.
	ENDIF
ENDIF
* print this data, if we're on or after starting page
IF m->gn_pno >= m->gn_startpg
	* then print the string
	?? m->lc_string
ENDIF
* update the column position
gn_outcol = m->gn_outcol + m->ln_l
RETURN

******************************************
PROCEDURE rr_outfs
PARAMETERS lc_string, lc_style
* output string with style/font attributes
******************************************
PRIVATE ln_l, ln_n
ln_l = LEN(m->lc_string)
* ignore null string
IF m->ln_l = 0
	RETURN
ENDIF
* if the line is blank so far
IF m->gl_blank
	* and these are more spaces
	IF LEN(TRIM(m->lc_string)) = 0
		* update the column position and exit
		gn_outcol = m->gn_outcol + m->ln_l
		RETURN
	* first non-blank data on line - space over to it
	ELSE
		* if we're on or after starting page
		IF m->gn_pno >= m->gn_startpg
			IF m->gc_dest <> 'D'
				?? SPACE(m->gn_indent)
			ENDIF
			?? SPACE(m->gn_outcol)
		ENDIF
		gl_blank = .F.
	ENDIF
ENDIF
* print this data, if we're on or after starting page
IF m->gn_pno >= m->gn_startpg
	* trim and print the leading spaces
	ln_n = m->ln_l - LEN(LTRIM(m->lc_string))
	?? SPACE(m->ln_n)
	* then set the style
	DO rr_style WITH m->lc_style
	* then the trimmed string
	?? LTRIM(m->lc_string)
	* then reset the style
	DO rr_style WITH 'bui00'
ENDIF
* update the column position
gn_outcol = m->gn_outcol + m->ln_l
RETURN

******************************************
PROCEDURE rr_outfsz
PARAMETERS lc_string, lc_style
* output string with style/font attributes
******************************************
PRIVATE ln_l, ln_n
ln_l = LEN(m->lc_string)
* ignore null string
IF m->ln_l = 0
	RETURN
ENDIF
* trim and print the leading spaces
ln_n = m->ln_l - LEN(LTRIM(m->lc_string))
?? SPACE(m->ln_n)
* then set the style
DO rr_style WITH m->lc_style
* then the trimmed string
?? LTRIM(m->lc_string)
* then reset the style
DO rr_style WITH 'bui00'
RETURN

******************************************
PROCEDURE rr_outl
PARAMETERS ll_cmpress
* output line with possible blank compress
******************************************
&& IF m->gc_dest = 'P'
	&& insert check for printer ready here
&& ENDIF
* if there's anything on this line and no compress
IF .NOT. (m->gl_blank .AND. m->gl_cmpress .AND. m->ll_cmpress)
	* and we're past the starting page
	IF m->gn_pno >= m->gn_startpg
		* print the line
		?
		* if destination is display, check for screen full
		IF m->gc_dest = 'D'
			DO rr_wait
		ENDIF
	ENDIF
	* update the line number
	gn_lno = m->gn_lno + 1
ENDIF
* current line is blank so far; current column is 0
gl_blank = .T.
gn_outcol = 0
RETURN

**************************************************
PROCEDURE rr_style
PARAMETERS lc_style
* change print style including attributes and font
**************************************************
PRIVATE lc_color, lc_font, lc_oldfon, lc_newfon
* if destination is display
IF m->gc_dest = 'D'
	* default is low intensity
	lc_color = wbbrbg
	* if turn underline on
	IF SUBSTR(m->lc_style, 2, 1) = 'U'
		* set the color to U
		lc_color = 'U'
	ENDIF
	* if turn bold on
	IF LEFT(m->lc_style, 1) = 'B'
		* append the high intensity indicator
		lc_color = grb
	ENDIF
	SET COLOR TO &lc_color.
* if destination is printer or file to be printed later
ELSE
	IF m->gc_printer <> 'A'
		* if bold turned on/off, output appropriate code
		?? IIF(LEFT(m->lc_style, 1) # LEFT(m->gc_style, 1),  IIF(LEFT(;
			m->lc_style, 1) = 'B', m->gc_psbdon, m->gc_psbdoff),'')
		* if underline turned on/off, output appropriate code
		?? IIF(SUBSTR(m->lc_style, 2, 1) # SUBSTR(m->gc_style, 2, 1), IIF(;
			SUBSTR(m->lc_style, 2, 1) = 'U',m->gc_psulon,m->gc_psuloff),'')
		* if italics turned on/off, output appropriate code
		?? IIF(SUBSTR(m->lc_style, 3, 1) # SUBSTR(m->gc_style, 3, 1), IIF(;
			SUBSTR(m->lc_style, 3, 1) = 'I',m->gc_psiton,m->gc_psitoff),'')
		* extract font numbers
		lc_oldfon = RIGHT(m->gc_style, 2)
		lc_newfon = RIGHT(m->lc_style, 2)
		* if font changed, output appropriate code
		?? IIF(m->lc_oldfon # m->lc_newfon, IIF(m->lc_newfon = '00', ;
			m->gc_psf&lc_oldfon.of, m->gc_psf&lc_newfon.on), '')
		* remember new style
		gc_style = m->lc_style
	ENDIF
ENDIF
RETURN

***************************
PROCEDURE rr_wait
* wait after each screenful
***************************
gn_slno = m->gn_slno + 1
IF m->gn_slno >= 24
	WAIT
	@ ROW(),0
	@ ROW()-1, 0
	gn_slno = 1
ENDIF
RETURN

*************************
FUNCTION percent
PARAMETERS lN_POS, lN_NEG
*************************
RETURN IIF(m->lN_POS+m->lN_NEG#0,TRANSFORM((m->lN_POS*100)/(m->lN_NEG+;
	m->lN_POS),'999.9'),'  0.0')

***************************
FUNCTION adddays
PARAMETERS ld_date, ln_days
* add days to date
***************************
* add the number of days to the date
RETURN m->ld_date + m->ln_days

***************************
FUNCTION addmons
PARAMETERS ld_date, ln_mons
* add months to date
***************************
PRIVATE ln_newmon, ln_newday, ln_newyr, ld_ret
* default to blank date
ld_ret = rr_ctod('','','')
* if date is not blank
IF .NOT.(m->ld_date = rr_ctod('','',''))
	* calculate the new month between -10 and 23
	ln_newmon = MONTH(m->ld_date)+m->ln_mons%IIF(m->ln_mons>0,12,-12)
	* calculate the new year
	ln_newyr = YEAR(m->ld_date)+INT(m->ln_mons/12)+IIF(m->ln_newmon<1,-1,IIF(;
		m->ln_newmon>12,1,0))
	* scale new month to within 1 and 12
	ln_newmon = m->ln_newmon+IIF(m->ln_newmon<1,12,IIF(m->ln_newmon>12,-12,0))
	* calculate new day not to exceed last day of new month
	ln_newday = MIN(DAY(m->ld_date),rr_daymax(m->ln_newmon,m->ln_newyr))
	* convert month, day, and year back to date
	ld_ret = rr_ctod(STR(m->ln_newmon,2),STR(m->ln_newday,2),STR(m->ln_newyr,4))
ENDIF
* return the resulting date
RETURN m->ld_ret

**************************
FUNCTION addwks
PARAMETERS ld_date, ln_wks
* add weeks to date
**************************
* add seven times the number of weeks to the date
RETURN m->ld_date + 7*m->ln_wks

**************************
FUNCTION addyrs
PARAMETERS ld_date, ln_yrs
* add years to date
**************************
PRIVATE ld_ret
* if date isn't blank, add the number of years while adjusting
* the day not to exceed the last day of the month in leap years
ld_ret = IIF(m->ld_date = rr_ctod('','',''),rr_ctod('','',''),rr_ctod(STR(;
	MONTH(m->ld_date),2),STR(MIN(DAY(m->ld_date),rr_daymax(MONTH(m->ld_date),;
	YEAR(m->ld_date)+m->ln_yrs)),2),STR(YEAR(m->ld_date)+m->ln_yrs,4)))
* return the resulting date
RETURN m->ld_ret

***********************************************
FUNCTION capfirst
PARAMETERS lc_str, lc_bstr
* capitalize only the first letter in each word
***********************************************
PRIVATE lc_ret, ln_ptr, ll_inword, lc_chr
* default to a null string
lc_ret = ''
* remove trailing spaces
lc_str = TRIM(m->lc_str)
* if the input string isn't null
IF LEN(m->lc_str) > 0
	* point to the first character
	ln_ptr = 1
	* we're not within a word yet
	ll_inword=.F.
	* process each character in the string
	DO WHILE m->ln_ptr <= LEN(m->lc_str)
		* store the current character
		lc_chr = SUBSTR(lc_str,m->ln_ptr,1)
		* if we're within a word
		IF m->ll_inword
			* if it's a word-break character
			IF m->lc_chr$lc_bstr
				* we're no longer within a word
				ll_inword = .F.
			ENDIF
			* append the current character to the result in lower case
			lc_ret = m->lc_ret + LOWER(m->lc_chr)
		* if we're not within a word
		ELSE
			* if it's not a word-break character
			IF .NOT.(m->lc_chr$lc_bstr)
				* we're now within a word (and it's the first character)
				ll_inword = .T.
			ENDIF
			* append the current character to the result in upper case
			lc_ret = m->lc_ret + UPPER(m->lc_chr)
		ENDIF
		* point to the next character
		ln_ptr = m->ln_ptr + 1
	ENDDO
ENDIF
* return the resulting string
RETURN m->lc_ret

**************************
FUNCTION ceiling
PARAMETERS ln_num
* emulates dBASE CEILING()
**************************
PRIVATE ln_ret
* return the first integer greater than or equal to the input number
ln_ret = IIF(INT(m->ln_num)=m->ln_num,m->ln_num,INT(m->ln_num+1))
RETURN m->ln_ret

*********************************************
FUNCTION datelike
PARAMETERS lc_month, lc_day, lc_year, ld_date
* compare date to wildcard
*********************************************
* compare the month, day, and year to the system date or input date
RETURN (m->lc_month='*'.OR.(VAL(m->lc_month)=MONTH(m->ld_date)).OR.;
	(m->lc_month='@'.AND.MONTH(date())=MONTH(m->ld_date))).AND.;
	(m->lc_day='*'.OR.(VAL(m->lc_day)=DAY(m->ld_date)).OR.;
	(m->lc_day='@'.AND.DAY(date())=DAY(m->ld_date))).AND.;
	(m->lc_year='*'.OR.(VAL(m->lc_year)=YEAR(m->ld_date)).OR.;
	(m->lc_year='@'.AND.YEAR(date())=YEAR(m->ld_date)))

*****************************
FUNCTION daysbtwn
PARAMETERS ld_date1, ld_date2
* days between dates
*****************************
* subtract the second date from the first date
RETURN m->ld_date1 - m->ld_date2

******************************
FUNCTION dqtr
PARAMETERS ld_date
* first day of quarter of date
******************************
PRIVATE ld_ret
* build a date using the first day of the first month of the quarter
ld_ret = rr_ctod(STR(qtr(m->ld_date)*3-2,2), '01', STR(YEAR(m->ld_date),4))
RETURN m->ld_ret

********************************************
FUNCTION edit_cc
PARAMETERS ln_num, ln_ints, ln_decs, lc_type
* edit number to Currency or Comma format
********************************************
PRIVATE lc_ret, ln_ptr, ln_decpos
ln_num = ROUND(m->ln_num,m->ln_decs)
DO CASE
	* zero with no integers shouldn't be asterisks
	CASE m->ln_num = 0 .AND. m->ln_ints = 0
		* show zeros rather than asterisks
		lc_ret = ' ' + m->gc_point + REPLICATE('0', m->ln_decs) + ' '
	* all other numbers
	OTHERWISE
		* do a standard transform
		lc_ret = TRANSFORM(m->ln_num, ('@( ' + IIF(m->ln_ints > 0, RIGHT('99' ;
			+ REPLICATE(',999', 6), m->ln_ints + ceiling((m->ln_ints - 3)/ 3));
			, '') + IIF(m->ln_decs > 0, '.' + REPLICATE('9',m->ln_decs), '')))
		* special cases for international punctuation
		DO CASE
			CASE m->gc_point # '.' .AND. m->gc_tsep # ','
				ln_decpos = AT('.',m->lc_ret)
				IF m->ln_decpos > 0
					lc_ret = STUFF(m->lc_ret, m->ln_decpos, 1, '')
				ENDIF
				lc_ret = STRTRAN(m->lc_ret, ',', m->gc_tsep)
				IF m->ln_decpos > 0
					lc_ret = STUFF(m->lc_ret, m->ln_decpos, 0, m->gc_point)
				ENDIF
			CASE m->gc_point # '.'
				ln_decpos = AT('.',m->lc_ret)
				IF m->ln_decpos > 0
					lc_ret = STUFF(m->lc_ret, m->ln_decpos, 1, m->gc_point)
				ENDIF
			CASE m->gc_tsep # ','
				lc_ret = STRTRAN(m->lc_ret, ',', m->gc_tsep)
		ENDCASE
ENDCASE
* now apply the finishing touches...
* if fraction or zero and at least one integer and decimal place
IF m->ln_num<1 .AND. m->ln_num>-1 .AND. m->ln_ints>0 .AND. m->ln_decs>0
	* if there's not already a zero before decimal point
	IF SUBSTR(m->lc_ret,AT(m->gc_point,m->lc_ret)-1,1) <> '0'
		* insert leading zero before decimal point
		lc_ret = STUFF(m->lc_ret, AT(m->gc_point, m->lc_ret), 0, '0')
		* if there's a space
		IF ' ' $ m->lc_ret
			* delete it to compensate for the zero we inserted
			lc_ret = STUFF(m->lc_ret, AT(' ', m->lc_ret), 1, '')
		ENDIF
	ENDIF
ENDIF
* if negative number, move open parenthesis next to high order digit
IF LEFT(m->lc_ret, 1) = '('
	* replace the open parenthesis with a space
	lc_ret = STUFF(m->lc_ret, 1, 1, ' ')
	ln_ptr = 1
	* find first non-space character
	DO WHILE SUBSTR(m->lc_ret, m->ln_ptr, 1) = ' '
		ln_ptr = m->ln_ptr + 1
	ENDDO
	* remember the formatted numeric value
	ln_num = VAL(m->lc_ret)
	* insert the open parenthesis
	lc_ret = STUFF(m->lc_ret, m->ln_ptr, 0, '(')
* if non-negative number
ELSE
	* remember the formatted value
	ln_num = VAL(m->lc_ret)
	* add space where parens would be
	lc_ret = ' ' + m->lc_ret + ' '
ENDIF
* if number as formatted is zero and format is blank-zero (not show-zero)
IF m->ln_num = 0 .AND. (LEFT(m->lc_type,1) = ' ')
	* return blank
	RETURN REPLICATE(' ', LEN(m->lc_ret))
ENDIF
* remove any trailing space
lc_ret = RTRIM(m->lc_ret)
* if currency format insert the currency sign
IF RIGHT(m->lc_type,1) = 'C'
	* if suffix
	IF m->gc_cpos = 'R'
		* position of currency sign is at end before )
		ln_ptr = LEN(m->lc_ret) + 1
		IF RIGHT(m->lc_ret,1) = ')'
			ln_ptr = m->ln_ptr - 1
		ENDIF
	* if prefix
	ELSE
		* position of currency sign if after leading spaces or (
		ln_ptr = 1
		DO WHILE SUBSTR(m->lc_ret, m->ln_ptr, 1) $ ' ('
			ln_ptr = m->ln_ptr + 1
		ENDDO
	ENDIF
* insert the currency sign
lc_ret = STUFF(m->lc_ret, m->ln_ptr, 0, m->gc_csign)
ENDIF
RETURN m->lc_ret

*********************************
FUNCTION edit_da
PARAMETERS ld_date, ln_format
* edit date to abbreviated format
*********************************
IF m->ld_date = CTOD('  /  /  ')
	RETURN ''
ENDIF
PRIVATE lc_ret, lc_month, lc_year, lc_day
lc_year = RIGHT('000' + LTRIM(STR(YEAR(m->ld_date),4)),4)
IF m->ln_format > 5
	lc_year = RIGHT(m->lc_year,2)
	ln_format = m->ln_format - 5
ENDIF
lc_day = RIGHT('0' + LTRIM(STR(DAY(m->ld_date),2)),2)
DO CASE
	CASE m->ln_format < 4
		lc_month = LEFT(CMONTH(m->ld_date),3)
		DO CASE
			CASE m->ln_format = 1
				lc_ret = m->lc_day + '-' + m->lc_month + '-' + m->lc_year
			CASE m->ln_format = 2
				lc_ret = m->lc_day + '-' + m->lc_month
			CASE m->ln_format = 3
				lc_ret = m->lc_month + '-' + m->lc_year
		ENDCASE
	OTHERWISE
		lc_month = RIGHT('0' + LTRIM(STR(MONTH(m->ld_date),2)),2)
		DO CASE
			CASE m->gc_idate = 'A'
				lc_ret = m->lc_month + '/' + m->lc_day + IIF(m->ln_format=4,;
					'/' + m->lc_year,'')
			CASE m->gc_idate = 'B'
				lc_ret = m->lc_day + '/' + m->lc_month + IIF(m->ln_format=4,;
					'/' + m->lc_year,'')
			CASE m->gc_idate = 'C'
				lc_ret = m->lc_day + '.' + m->lc_month + IIF(m->ln_format=4,;
					'.' + m->lc_year,'')
			CASE m->gc_idate = 'D'
				lc_ret = + IIF(m->ln_format=4,m->lc_year+'-','') + ;
					m->lc_month + '-' + m->lc_day
		ENDCASE
ENDCASE
RETURN m->lc_ret

*****************************
FUNCTION edit_df
PARAMETERS ld_date, ln_format
* edit date to full format
*****************************
IF m->ld_date = CTOD('  /  /  ')
	RETURN ''
ENDIF
PRIVATE lc_ret, lc_month, lc_year, lc_day
lc_month = CMONTH(m->ld_date)
lc_year = RIGHT('000' + LTRIM(STR(YEAR(m->ld_date),4)),4)
lc_day = LTRIM(STR(DAY(m->ld_date),2))
DO CASE
	CASE m->ln_format = 1
		lc_ret = m->lc_month + ' ' + m->lc_day + ', ' + m->lc_year
	CASE m->ln_format = 2
		lc_ret = m->lc_day + ' ' + m->lc_month + ' ' + m->lc_year
	CASE m->ln_format = 3
		lc_ret = m->lc_month + ' ' + m->lc_year
	CASE m->ln_format = 4
		lc_ret = m->lc_month + ' ' + m->lc_day
	CASE m->ln_format = 5
		lc_ret = m->lc_day + ' ' + m->lc_month
ENDCASE
RETURN m->lc_ret

********************************************
FUNCTION edit_fp
PARAMETERS ln_num, ln_ints, ln_decs, lc_type
* edit number to Fixed or Percent format
********************************************
PRIVATE lc_ret
* if percent format
IF RIGHT(m->lc_type,1) = 'P'
	* multiply number by 100
	ln_num = m->ln_num * 100
ENDIF
ln_num = ROUND(m->ln_num,m->ln_decs)
* format the number (there are two special cases)
DO CASE
	* zero with no integers shouldn't be asterisks
	CASE m->ln_num = 0 .AND. m->ln_ints = 0
		* show zeros rather than asterisks
		lc_ret = '.' + REPLICATE('0', m->ln_decs)
	* negative numbers with ln_ints integer places shouldn't be asterisks
	CASE m->ln_num < 0
		* format number with one extra integer place for minus sign
		lc_ret = TRANSFORM(m->ln_num, (REPLICATE('9', m->ln_ints + 1) + IIF(;
			m->ln_decs > 0, '.' + REPLICATE('9', m->ln_decs), '')))
		* if first character isn't a minus sign (it's a space or asterisk)
		IF LEFT(m->lc_ret,1) # '-'
			* delete it to compensate for the minus sign we inserted
			lc_ret = STUFF(m->lc_ret, 1, 1, '')
		ENDIF
	* all other numbers
	OTHERWISE
		* just do a standard transform
		lc_ret = TRANSFORM(m->ln_num, (IIF(m->ln_ints>0, REPLICATE('9',;
			m->ln_ints), '') + IIF(m->ln_decs > 0, '.' + REPLICATE('9',;
			m->ln_decs), '')))
ENDCASE
* now apply the finishing touches...
* if international decimal point
IF m->gc_point # '.' .AND. AT('.',m->lc_ret) > 0
	lc_ret = STRTRAN(m->lc_ret, '.', m->gc_point)
ENDIF
* if percent format
IF RIGHT(m->lc_type,1) = 'P'
	* append a percent sign
	lc_ret = m->lc_ret + '%'
ENDIF
* if fixed format with no decimal places and fill with leading zeros
IF RIGHT(m->lc_type,1) = 'F' .AND. m->ln_decs = 0 .AND. LEFT(m->lc_type,1) = '0'
	* replace leading spaces with zeros
	lc_ret = REPLICATE('0',LEN(m->lc_ret) - LEN(LTRIM(m->lc_ret))) + LTRIM(;
		m->lc_ret)
	* if number as formatted is negative
	IF '-'$m->lc_ret
		* move minus sign to prefix
		lc_ret = '-' + STUFF(m->lc_ret, AT('-', m->lc_ret), 1, '')
	ENDIF
ENDIF
* if fraction or zero and at least one integer and decimal place
IF m->ln_num<1 .AND. m->ln_num>-1 .AND. m->ln_ints>0 .AND. m->ln_decs>0
	* if there's not already a zero before decimal point
	IF SUBSTR(m->lc_ret,AT(m->gc_point,m->lc_ret)-1,1) <> '0'
		* insert leading zero before decimal point
		lc_ret = STUFF(m->lc_ret, AT(m->gc_point, m->lc_ret), 0, '0')
		* if first character is a space
		IF LEFT(m->lc_ret, 1) = ' '
			* delete it to compensate for the zero we inserted
			lc_ret = STUFF(m->lc_ret, 1, 1, '')
		ENDIF
	ENDIF
ENDIF
* if number as formatted is zero
IF VAL(m->lc_ret) = 0
	DO CASE
		* if format is blank-zero (not show-zero)
		CASE SUBSTR(m->lc_type,2,1) = ' '
			* format result as blank
			lc_ret = REPLICATE(' ', LEN(m->lc_ret))
		* if there's a minus sign
		CASE '-' $ m->lc_ret
			* delete it
			lc_ret = STUFF(m->lc_ret, AT('-', m->lc_ret), 1, '')
	ENDCASE
ENDIF
* return the result
RETURN m->lc_ret

******************************
FUNCTION edit_l
PARAMETERS ll_value
* edit value to logical format
******************************
* return the appropriate logical string
RETURN IIF(m->ll_value,m->gc_true,m->gc_false)

******************************************
FUNCTION edit_sg
PARAMETERS ln_num, ln_wid, lc_type
* edit number to scientific/general format
******************************************
PRIVATE lc_ret, ln_rw, ln_len, ln_dec, ln_exp, ln_dot, ln_sign
PRIVATE ln_ptr1, ln_ptr2
ln_sign = IIF(m->ln_num < 0,1,0)
ln_num = ABS(m->ln_num)
* compute result field width
ln_rw = m->ln_wid + IIF(RIGHT(m->lc_type,1)='S',IIF(m->ln_wid=0,5,6) + ;
	m->ln_sign,0)
* handle zero separately
IF m->ln_num = 0
	* show zero
	IF LEFT(m->lc_type,1) = '0'
		lc_ret = '0'
		IF RIGHT(m->lc_type,1) = 'S'
			lc_ret = m->lc_ret + IIF(m->ln_wid>0,m->gc_point,'') + REPLICATE(;
				'0',m->ln_wid)+'E+00'
		ENDIF
	* blank zero
	ELSE
		lc_ret = ''
	ENDIF
ELSE
	* convert number to string with the most decimal places that fit
	lc_ret = STR(m->ln_num,20,MAX(19-LEN(LTRIM(STR(INT(m->ln_num),20,0))),0))
	lc_ret = LTRIM(RTRIM(m->lc_ret))
	* prepare to trim leading/trailing zeros
	* point past leading zeros
	ln_ptr1 = 1
	DO WHILE SUBSTR(m->lc_ret,m->ln_ptr1,1) = '0'
		ln_ptr1 = m->ln_ptr1+1
	ENDDO
	* point to last non zero fractional digit or "ones" place
	ln_ptr2 = LEN(m->lc_ret)
	IF '.' $ m->lc_ret
		DO WHILE SUBSTR(m->lc_ret,m->ln_ptr2,1) = '0'
			ln_ptr2 = m->ln_ptr2-1
		ENDDO
	ENDIF
	ln_ptr2 = IIF(SUBSTR(m->lc_ret,m->ln_ptr2,1) = '.',m->ln_ptr2-1,m->ln_ptr2)
	* remove the leading and trailing zeros
	lc_ret = SUBSTR(m->lc_ret,m->ln_ptr1,m->ln_ptr2-m->ln_ptr1+1)
	* calculate the string length
	ln_len = LEN(m->lc_ret)
	* locate decimal point
	ln_dot = AT('.',m->lc_ret)
	* count number of integer places
	ln_int = IIF(m->ln_dot=0,m->ln_len,m->ln_dot-1)
	* count number of decimal places
	ln_dec = IIF(m->ln_dot=0,0,m->ln_len-m->ln_dot)
	* general format and field is wide enough for all integers
	IF RIGHT(m->lc_type,1) = 'G' .AND. m->ln_int + m->ln_sign <= m->ln_wid
		* show the most decimal places that fit in field width without
		* trailing zeros, leave room for leading zero if fraction
		lc_ret = LTRIM(STR(VAL(m->lc_ret),m->ln_wid,MIN(m->ln_dec,MAX(;
			m->ln_wid-(MAX(1,m->ln_int)+1+m->ln_sign),0))))
		* handle special cases
		DO CASE
			* if value rounded to zero, eliminate fraction
			CASE VAL(m->lc_ret) = 0
				lc_ret = '0'
				* if leading decimal point, append a zero
			CASE LEFT(m->lc_ret,1) = '.'
				lc_ret = '0'+m->lc_ret
			ENDCASE
		* scientific format, or general format and field too narrow
	ELSE
		* if scientific format increase width to accommodate
		* minus sign and exponent
		ln_wid = m->ln_wid+IIF(RIGHT(m->lc_type,1)='S',IIF(m->ln_wid=0,5,6)+;
			m->ln_sign,0)
		* if field is wide enough for scientific format, format it
			IF (m->ln_sign#0.AND.m->ln_wid>=6).OR.(m->ln_sign=;
				0.AND.m->ln_wid>=5)
				* calculate exponent
				ln_exp = AT('.',m->lc_ret)
				DO CASE
					CASE m->ln_exp = 0
						ln_exp = LEN(m->lc_ret)-1
					CASE m->ln_exp = 1
						DO WHILE SUBSTR(m->lc_ret,m->ln_exp+1,1) = '0'
							ln_exp = m->ln_exp+1
						ENDDO
						ln_exp = -m->ln_exp
					OTHERWISE
						ln_exp = m->ln_exp-2
				ENDCASE
				* remove original decimal point
				lc_ret = IIF('.'$m->lc_ret,STUFF(m->lc_ret,AT('.',m->lc_ret),;
					1,''),m->lc_ret)
				* remove leading zeros
				ln_ptr1 = 1
				DO WHILE SUBSTR(m->lc_ret,m->ln_ptr1,1) = '0'
					ln_ptr1 = m->ln_ptr1+1
				ENDDO
				lc_ret = SUBSTR(m->lc_ret,m->ln_ptr1)
				* insert decimal point after first digit
				lc_ret = STUFF(m->lc_ret,2,0,'.')
				* length of number must be smaller than field
				* width to leave room for exponent
				ln_len = m->ln_wid - (4 + m->ln_sign)
				* calculate the most decimal places that fit
				ln_dec = MAX(m->ln_len-2,0)
				* get all the decimal places
				lc_ret = LTRIM(STR(ROUND(VAL(m->lc_ret),m->ln_dec),MAX(;
					m->ln_len,1),m->ln_dec))
				* add the exponent
				lc_ret = m->lc_ret+'E'+IIF(m->ln_exp<0,'-','+') + IIF(ABS(;
					m->ln_exp)<10,'0','')+LTRIM(STR(ABS(m->ln_exp),2,0))
				* if value too wide for field, return asterisks
			ELSE
				lc_ret = REPLICATE('*',m->ln_wid)
			ENDIF
		ENDIF
	ENDIF
* add a minus sign to negative numbers, unless value is asterisks or '0'
lc_ret = IIF(m->ln_sign#0.AND.LEFT(m->lc_ret,1)#'*'.AND.'0'#m->lc_ret,'-','')+;
	m->lc_ret
* if international decimal point
IF m->gc_point # '.' .AND. AT('.',m->lc_ret) > 0
	lc_ret = STRTRAN(m->lc_ret, '.', m->gc_point)
ENDIF
* right justify the result
IF m->ln_rw > LEN(m->lc_ret)
	lc_ret = SPACE(m->ln_rw - LEN(m->lc_ret)) + m->lc_ret
ENDIF
* return the resulting string
RETURN m->lc_ret

**************************
FUNCTION flip
PARAMETERS lc_str, lc_fstr
* exchange character data
**************************
PRIVATE lc_ret, lc_fchr
* default is to return the input string unchanged
lc_ret = m->lc_str
* if there's a flip string
IF LEN(m->lc_fstr) > 0
	* three cases: first part, last part, and both parts reversed
	DO CASE
		* if we need the first part
		CASE LEFT(m->lc_fstr,1) = '*'
			* store the flip character
			lc_fchr = SUBSTR(m->lc_fstr,2,1)
			* if there's a flip character and it appears in the string
			IF LEN(m->lc_fchr) > 0 .AND. m->lc_fchr$m->lc_str
				* extract the substring up to, but not including the flip
					*character
				lc_ret = TRIM(SUBSTR(m->lc_str,1,AT(m->lc_fchr,m->lc_str)-1))
			ENDIF
		OTHERWISE
			IF LEN(m->lc_fstr) > 1
				IF (SUBSTR(m->lc_fstr,2,1) = '*')
					* if we need the last part
					* store the flip character
					lc_fchr = LEFT(m->lc_fstr,1)
					* if there's a flip character
					IF LEN(m->lc_fchr) > 0
						* extract the substring beginning after
						* the flip character
						lc_ret = LTRIM(TRIM(SUBSTR(m->lc_str,AT(m->lc_fchr,;
							m->lc_str)+1)))
					ENDIF
					RETURN lc_ret
				ENDIF
			ENDIF
			* store the flip character
			lc_fchr = LEFT(m->lc_fstr,1)
			* if the flip character appears in the string
			IF m->lc_fchr$m->lc_str
				* extract the second part, a space, and then the first part
				lc_ret = LTRIM(LTRIM(TRIM(SUBSTR(m->lc_str,AT(m->lc_fchr,;
					m->lc_str)+1))) + SPACE(1) + TRIM(SUBSTR(m->lc_str,1,AT(;
					m->lc_fchr,m->lc_str)-1)))
			ENDIF
	ENDCASE
ENDIF
* return the resulting string
RETURN m->lc_ret

******************
FUNCTION hiscope
* high scope value
******************
* return the high scope value saved with the report


*****************************************
FUNCTION inrange
PARAMETERS lx_val, lx_low, lx_hi
* Determine if value between low and high
*****************************************
* test whether the value is within the specified range
RETURN m->lx_val >= m->lx_low .AND. m->lx_val <= m->lx_hi

******************************************************
FUNCTION like
PARAMETERS lc_pat, lc_str
* Determine if pattern (with wildcards) matches string
******************************************************
PRIVATE ln_pptr, ln_sptr, ln_pctr, ln_pend, lc_pchr, lc_schr
PRIVATE ln_qctr, ln_qend
lc_str = RTRIM(m->lc_str)
* initialize pointers to pattern and target string and substring text
ln_pptr = 1
ln_sptr = 1
ln_pctr = 1
ln_pend = 1
ln_qend = 1
ln_qctr = 1
* get next character in both pattern and target string text
lc_pchr = SUBSTR(m->lc_pat,m->ln_pptr,1)
lc_schr = SUBSTR(m->lc_str,m->ln_sptr,1)
DO WHILE .T.
	IF m->lc_pchr = '*'
	* '*' implies match any number of characters (0 or more)
	* First position past sequence with '?' or consecutive '*' characters
		DO WHILE .T.
			ln_pptr = m->ln_pptr + 1
			* check for end of pattern - done if so
			IF m->ln_pptr > LEN(m->lc_pat)
				RETURN .T.
			ENDIF
			lc_pchr = SUBSTR(m->lc_pat,m->ln_pptr,1)
			IF m->lc_pchr <> '*' .AND. m->lc_pchr <> '?'
				EXIT
			ENDIF
		ENDDO
		* Get pattern characters until next '*' or end of string
		ln_pctr = AT('*', SUBSTR(m->lc_pat,m->ln_pptr))
		IF m->ln_pctr = 0
			ln_pend = 1     && LEN(lc_pat) - m->ln_pptr
		ELSE
			ln_pend = m->ln_pctr - 1
		ENDIF
		ln_qctr = AT('?', SUBSTR(m->lc_pat,m->ln_pptr))
		IF m->ln_qctr <> 0
			ln_qend = m->ln_qctr - 1
			ln_pend = MIN(m->ln_pend, m->ln_qend)
		ENDIF
		* Check the target string against the pattern substring between '*'
		*      characters or from character following '*' to end of pattern.
		*      If no match, update pointer and check next n characters.
		DO WHILE .T.
			IF UPPER(SUBSTR(m->lc_pat,m->ln_pptr,m->ln_pend)) = UPPER(SUBSTR(;
				m->lc_str,m->ln_sptr,m->ln_pend))
				IF m->ln_qctr = 0
					RETURN .T.
				ELSE
					ln_pptr = m->ln_pptr + m->ln_pend
					ln_sptr = m->ln_sptr + m->ln_pend
					IF .NOT. (m->ln_pptr > LEN(m->lc_pat)) .AND. .NOT. (;
						m->ln_sptr > LEN(m->lc_str))
						* Get next character values from pattern and target
							*strings.
						lc_pchr = SUBSTR(m->lc_pat,m->ln_pptr,1)
						lc_schr = SUBSTR(m->lc_str,m->ln_sptr,1)
					ENDIF
					EXIT
				ENDIF
			ELSE
				ln_sptr = m->ln_sptr+1
				IF m->ln_sptr > LEN(m->lc_str)
					RETURN .F.
				ENDIF
			ENDIF
		ENDDO
	ENDIF
	* Check for end of string, not end of pattern - no match if so.
	IF m->ln_sptr > LEN(m->lc_str)
		RETURN .F.
	ENDIF
	* Check for individual character matches, position by position.
	*      '?' always matches its corresponding target string character.
	*      If no '?', check for real character match.
		IF m->lc_pchr = '?' .AND. (m->ln_sptr > LEN(m->lc_str))
			RETURN .F.
		ENDIF
		IF m->lc_pchr = '?' .OR. UPPER(m->lc_pchr) = UPPER(m->lc_schr)
		* Advance pattern and target string pointers.
			ln_pptr = m->ln_pptr+1
			ln_sptr = m->ln_sptr+1
			IF .NOT. (m->ln_pptr > LEN(m->lc_pat))
				* Get next character value from pattern.
				lc_pchr = SUBSTR(m->lc_pat,m->ln_pptr,1)
			ENDIF
			IF .NOT. (m->ln_sptr > LEN(m->lc_str))
				* Get next character value from target string.
				lc_schr = SUBSTR(m->lc_str,m->ln_sptr,1)
			ENDIF
		ELSE
			RETURN .F.
		ENDIF
		IF m->ln_pptr > LEN(m->lc_pat)
			RETURN .T.
		ENDIF
	ENDDO
	RETURN .T.

*****************
FUNCTION loscope
* low scope value
*****************
* return the low scope value saved with the report


**************************
FUNCTION memolike
PARAMETERS lc_pat, lm_memo
* compare memo field
**************************
PRIVATE lc_s, ln_i
ln_i = 1
DO WHILE m->ln_i <= LEN(m->lm_memo)
	lc_s = LOWER(SUBSTR(m->lm_memo,m->ln_i,254))
	IF LIKE(m->lc_pat,m->lc_s)
		RETURN .T.
	ENDIF
	ln_i = m->ln_i + 254
ENDDO
RETURN .F.

*****************************
FUNCTION monsbtwn
PARAMETERS ld_date1, ld_date2
* months between dates
*****************************
PRIVATE ln_ret
* calculate absolute number of months between, excluding day of month
ln_ret = ABS(((YEAR(m->ld_date1)*12) + MONTH(m->ld_date1)) - ((YEAR(;
	m->ld_date2)*12) + MONTH(m->ld_date2)))
* if ending day is less than starting day, subtract 1
ln_ret = m->ln_ret - IIF(MAX(DAY(m->ld_date1),DAY(m->ld_date2)) < MIN(DAY(;
	m->ld_date1),DAY(m->ld_date2)),1,0)
* make number negative if date1 < date2
ln_ret = IIF(m->ld_date2>m->ld_date1, -m->ln_ret, m->ln_ret)
* return the number of months
RETURN m->ln_ret

***************
FUNCTION pageno
* page number
***************
* return the page number
RETURN m->gn_lpno

************************
FUNCTION qtr
PARAMETERS ld_date
* quarter number of date
************************
* calculate and return the calendar quarter
RETURN INT((MONTH(m->ld_date)+2)/3)

*******************************
FUNCTION rrunin
* current record of Runtime job
*******************************
* this function is undefined when not running under the R&R Runtime
RETURN 0

***********************
FUNCTION scanning
PARAMETERS ln_alias
* .T. if scanning alias
***********************
* undefined in RRCG Version 1
RETURN .T.

**************************************************
FUNCTION spellnum
PARAMETERS ln_num
* spells (integer portion of) a numeric expression
**************************************************
PRIVATE lc_ret, lc_nstr, ln_trips, ln_trip, lc_strip
* default to a null string
lc_ret = ''
* handle zero as a special case
IF m->ln_num < 1 .AND. m->ln_num > -1
	* just return the word 'zero'
	lc_ret = 'zero'
* if it's not zero
ELSE
	* if the number is negative
	IF m->ln_num < 0
		* begin with the word 'minus'
		lc_ret = 'minus'
	ENDIF
	* convert the number to a string without any minus sign
	lc_nstr = LTRIM(STR(ABS(INT(m->ln_num)),20))
	* calculate the number of triplets (i.e. groups of 3 integer places)
	ln_trips = CEILING(LEN(m->lc_nstr)/3)
	* start with the leftmost triplet
	ln_trip = m->ln_trips
	* spell each triplet
	DO WHILE m->ln_trip > 0
		* extract the next triplet string and spell it
		lc_strip = rr_strip(rr_gtrip(m->lc_nstr,m->ln_trip,m->ln_trips),;
			m->ln_trip)
		* if the triplet isn't all zeros
		IF LEN(m->lc_strip) > 0
			* append a space and the spelled triplet to the result
			lc_ret = m->lc_ret + IIF(LEN(m->lc_ret) > 0,' ','') + m->lc_strip
		ENDIF
		* calculate the number of the next triplet
		ln_trip = m->ln_trip - 1
	ENDDO
ENDIF
* capitalize the first letter of the result
lc_ret = IIF(LEN(m->lc_ret) > 0,UPPER(LEFT(m->lc_ret,1)) + SUBSTR(m->lc_ret,2);
	,'')
* return the resulting string
RETURN m->lc_ret

***************************
FUNCTION subdays
PARAMETERS ld_date, ln_days
* months between dates
***************************
* subtract the number of days from the date
RETURN m->ld_date - m->ln_days

***************************
FUNCTION submons
PARAMETERS ld_date, ln_mons
* months between dates
***************************
PRIVATE ld_ret
* add the negative number of months
ld_ret = addmons(m->ld_date,-m->ln_mons)
RETURN m->ld_ret

**************************
FUNCTION subwks
PARAMETERS ld_date, ln_wks
* months between dates
**************************
PRIVATE ld_ret
* add the negative number of weeks
ld_ret = addwks(m->ld_date,-m->ln_wks)
RETURN m->ld_ret

**************************
FUNCTION subyrs
PARAMETERS ld_date, ln_yrs
* months between dates
**************************
PRIVATE ld_ret
* add the negative number of years
ld_ret = addyrs(m->ld_date,-m->ln_yrs)
RETURN m->ld_ret

*****************************************
FUNCTION wdcount
PARAMETERS lc_str, lc_bstr
* number of words in character expression
*****************************************
PRIVATE ln_ret, ln_ptr, ll_inword, lc_chr
* default to a count of zero words
ln_ret = 0
* if the input string isn't null
IF .NOT. (EMPTY(m->lc_str))
	* point to the first character
	ln_ptr = 1
	* we're not within a word yet
	ll_inword = .F.
	* process each character in the string
	DO WHILE m->ln_ptr <= LEN(m->lc_str)
		* store the current character
		lc_chr = SUBSTR(lc_str,m->ln_ptr,1)
		* if we're within a word
		IF m->ll_inword
			* if it's a word-break character
			IF m->lc_chr$lc_bstr
				* we're no longer within a word
				ll_inword = .F.
			ENDIF
		* if we're not within a word
		ELSE
			* if it's not a word-break character
			IF .NOT. (m->lc_chr$lc_bstr)
				* we're now within a word (and it's the first character)
				ll_inword = .T.
				* increment the word count
				ln_ret = m->ln_ret + 1
			ENDIF
		ENDIF
		* point to the next character
		ln_ptr = m->ln_ptr + 1
	ENDDO
ENDIF
* return the word count
RETURN m->ln_ret

*******************
FUNCTION week
PARAMETERS ld_date
* week of the month
*******************
PRIVATE ln_ret
* calculate and return the week of the month of the input date
ln_ret = INT((DAY(m->ld_date) + DOW(rr_ctod(STR(MONTH(m->ld_date),2),'01',STR(;
	YEAR(m->ld_date),4))) + 5)/7)
RETURN m->ln_ret

*****************************
FUNCTION wksbtwn
PARAMETERS ld_date1, ld_date2
* weeks between dates
*****************************
* return the number of days between the two dates divided by seven
RETURN INT((m->ld_date1 - m->ld_date2)/7)

*****************************
FUNCTION yrsbtwn
PARAMETERS ld_date1, ld_date2
* years between dates
*****************************
PRIVATE ln_ret
* return the number of months between the two dates divided by twelve
ln_ret = INT(monsbtwn(m->ld_date1,m->ld_date2)/12)
RETURN m->ln_ret

**********************************************
FUNCTION rr_align
PARAMETERS lc_string, ln_width, lc_align
* align string within field width Center/Right
**********************************************
PRIVATE lc_ret, ln_k
lc_ret = TRIM(m->lc_string)
ln_k = LEN(m->lc_ret)
* if there's a string to align
IF m->ln_k > 0
	IF m->lc_align = 'C'
		* center align
		lc_ret = SPACE((m->ln_width - m->ln_k + 1)/2) + m->lc_ret
	ELSE
		* right align
		lc_ret = SPACE(m->ln_width - m->ln_k) + m->lc_ret
	ENDIF
ENDIF
* return result
RETURN m->lc_ret

************************************
FUNCTION rr_ctod
PARAMETERS lc_month, lc_day, lc_year
* a ctod for all seasons
************************************
PRIVATE ld_ret
* call CTOD() with the proper punctuation based on the R&R
* international date format: A, B, C, or D
DO CASE
	* American format (MM/DD/YY)
	CASE m->gc_idate = 'A'
		ld_ret =  CTOD(m->lc_month + '/' + m->lc_day + '/' + m->lc_year)
	* British format (DD/MM/YY)
	CASE m->gc_idate = 'B'
		ld_ret =  CTOD(m->lc_day + '/' + m->lc_month + '/' + m->lc_year)
	* German format (DD.MM.YY)
	CASE m->gc_idate = 'C'
		ld_ret =  CTOD(m->lc_day + '.' + m->lc_month + '.' + m->lc_year)
	* ANSI format with dash separator (YY-MM-DD)
	CASE m->gc_idate = 'D'
		ld_ret =  CTOD(m->lc_year + '-' + m->lc_month + '-' + m->lc_day)
ENDCASE
* return the converted date
RETURN m->ld_ret

*********************************
FUNCTION rr_daymax
PARAMETERS ln_month, ln_year
* number of days in month of year
*********************************
PRIVATE ln_ret
* calculate the last day of the specified month and year
* taking leap years into account
ln_ret = IIF(STR(m->ln_month,2)$' 1 3 5 7 81012',31,;
	IIF(STR(m->ln_month,2)$' 4 6 911',30,IIF(rr_leap(m->ln_year),29,28)))
* return the result
RETURN m->ln_ret

*************************
FUNCTION rr_dtoc
PARAMETERS ld_date
* date to yyyymmdd format
*************************
* return the date in YYYYMMDD format
RETURN TRANSFORM(YEAR(m->ld_date),'@L 9999') + TRANSFORM(MONTH(m->ld_date),'@';
	+'L 99') + TRANSFORM(DAY(m->ld_date),'@L 99')

****************************
FUNCTION rr_go_rec
PARAMETERS ln_area, ln_recno
* GOTO recno in area
****************************
PRIVATE ln_ret
SELECT (m->ln_area)
ln_ret = RECNO()
GOTO ln_recno
RETURN m->ln_ret

*************************************
FUNCTION rr_gtrip
PARAMETERS lc_nstr, ln_trip, ln_trips
* extract triplet from numeric string
*************************************
PRIVATE lc_ret
* extract and return the specified triplet from the numeric string
lc_ret = SUBSTR(m->lc_nstr,LEN(m->lc_nstr)-MIN(m->ln_trip*3,LEN(m->lc_nstr))+;
	1,IIF(m->ln_trip=m->ln_trips,LEN(m->lc_nstr)-(3*(m->ln_trips-1)),3))
RETURN m->lc_ret

******************
FUNCTION rr_leap
PARAMETERS ln_year
* is a leap year
******************
* determine and return whether or not the specified year is a leap year
RETURN m->ln_year%4=0 .AND. (.NOT.(m->ln_year%100=0 .AND. m->ln_year%400>0))

*******************************************
FUNCTION rr_mfilt
PARAMETERS lc_s
* filter non-graphic characters from string
*******************************************
PRIVATE ln_c, ln_i, ln_n
ln_n = LEN(m->lc_s)
ln_i = 1
DO WHILE m->ln_i <= m->ln_n
	ln_c = ASC(SUBSTR(m->lc_s,m->ln_i,1))
	DO CASE
		* replace tab by space
		CASE m->ln_c = 9
			lc_s = STUFF(m->lc_s,m->ln_i,1,' ')
		* delete other control character
		CASE m->ln_c < 32
			lc_s = STUFF(m->lc_s,m->ln_i,1,'')
			ln_n = m->ln_n - 1
			LOOP
		ENDCASE
		ln_i = m->ln_i + 1
	ENDDO
	RETURN m->lc_s

*******************
FUNCTION rr_none
PARAMETERS lc_str
* cardinal name 1-9
*******************
PRIVATE lc_ret
* return the specified unit's name
lc_ret = IIF(m->lc_str='1','one',IIF(m->lc_str='2','two',;
	IIF(m->lc_str='3','three',IIF(m->lc_str='4','four',;
	IIF(m->lc_str='5','five',IIF(m->lc_str='6','six',;
	IIF(m->lc_str='7','seven',IIF(m->lc_str='8','eight',;
	IIF(m->lc_str='9','nine','')))))))))
RETURN m->lc_ret

*********************
FUNCTION rr_nteen
PARAMETERS lc_str
* cardinal name 10-19
*********************
PRIVATE lc_ret
* return the specified teen's name
lc_ret = IIF(m->lc_str='0','ten',IIF(m->lc_str='1','eleven',;
	IIF(m->lc_str='2','twelve',IIF(m->lc_str='3','thirteen',;
	IIF(m->lc_str='4','fourteen',IIF(m->lc_str='5','fifteen',;
	IIF(m->lc_str='6','sixteen',IIF(m->lc_str='7','seventeen',;
	IIF(m->lc_str='8','eighteen',IIF(m->lc_str='9','nineteen',''))))))))))
RETURN m->lc_ret

*****************************
FUNCTION rr_nten
PARAMETERS lc_str
* cardinal name 20-90 (by 10)
*****************************
PRIVATE lc_ret
* return the specified ten's name
lc_ret = IIF(m->lc_str='2','twenty',IIF(m->lc_str='3','thirty',;
	IIF(m->lc_str='4','forty',IIF(m->lc_str='5','fifty',;
	IIF(m->lc_str='6','sixty',IIF(m->lc_str='7','seventy',;
	IIF(m->lc_str='8','eighty',IIF(m->lc_str='9','ninety',''))))))))
RETURN m->lc_ret

*******************
FUNCTION rr_ntrip
PARAMETERS ln_trip
* name of a triplet
*******************
PRIVATE lc_ret
* return the specified triplet's name
lc_ret = IIF(m->ln_trip=7,'quintillion',IIF(m->ln_trip=6,'quadrillion',;
	IIF(m->ln_trip=5,'trillion',IIF(m->ln_trip=4,'billion',;
	IIF(m->ln_trip=3,'million',IIF(m->ln_trip=2,'thousand',''))))))
RETURN m->lc_ret

*************************************
FUNCTION rr_seek
PARAMETERS lc_string, ln_fl, ln_kl
* adjust seek string to proper length
*************************************
PRIVATE ln_k
ln_k = LEN(m->lc_string)
* if shorter than R&R field length, pad with spaces
IF m->ln_k < m->ln_fl
	lc_string = lc_string + SPACE(m->ln_fl - m->ln_k)
ENDIF
* truncate string to key expression length
lc_string = LEFT(m->lc_string,m->ln_kl)
RETURN lc_string

***************************
FUNCTION rr_strip
PARAMETERS lc_nstr, ln_trip
* spell triplet
***************************
PRIVATE lc_ret, ln_ptr
* default to a null string
lc_ret = ''
* point to the first character in the triplet
ln_ptr = 1
* truncate leading zeros
DO WHILE LEFT(m->lc_nstr,1) = '0'
	* replace the zero with nothing, to remove it
	lc_nstr = STUFF(m->lc_nstr,1,1,'')
ENDDO
* if the triplet wasn't all zeros
IF LEN(m->lc_nstr) > 0
	* if there's a hundreds place
	IF LEN(m->lc_nstr) = 3
		* spell the hundreds place
		lc_ret = rr_none(SUBSTR(m->lc_nstr,1,1))+' hundred'
		* point to the next character in the triplet
		ln_ptr = m->ln_ptr+1
	ENDIF
	* if there's a tens place
	IF LEN(m->lc_nstr) >= 2
		DO CASE
			* if the tens place is greater than the teens
			CASE SUBSTR(m->lc_nstr,m->ln_ptr,1) > '1'
				* append the spelled tens place, and the ones place, if any
				lc_ret = m->lc_ret + IIF(LEN(m->lc_ret) > 0,' ','') + rr_nten(;
					SUBSTR(m->lc_nstr,m->ln_ptr,1)) + IIF(SUBSTR(m->lc_nstr,;
					m->ln_ptr+1,1) > '0','-','') + rr_none(SUBSTR(m->lc_nstr,;
					m->ln_ptr+1,1))
			* if the tens place is in the teens
			CASE SUBSTR(m->lc_nstr,m->ln_ptr,1) = '1'
				* append the spelled teen
				lc_ret = m->lc_ret + IIF(LEN(m->lc_ret) > 0,' ','') + ;
					rr_nteen(SUBSTR(m->lc_nstr,m->ln_ptr+1,1))
			* if the tens place is zero
			CASE SUBSTR(m->lc_nstr,m->ln_ptr,1) = '0'
				* append the spelled ones place
				lc_ret = m->lc_ret + IIF(LEN(m->lc_ret) > 0 .AND. SUBSTR(;
					m->lc_nstr,m->ln_ptr+1,1) > '0',' ','') + rr_none(SUBSTR(;
					m->lc_nstr,m->ln_ptr+1,1))
		ENDCASE
		* if there's no hundreds or tens place
	ELSE
		* spell the ones place
		lc_ret = rr_none(LEFT(m->lc_nstr,1))
	ENDIF
	* if this isn't the low order triplet, append the triplet's name
	lc_ret = m->lc_ret + IIF(m->ln_trip>1,' '+rr_ntrip(m->ln_trip),'')
ENDIF
* return the spelled triplet
RETURN m->lc_ret

***************************
FUNCTION rr_st_eq
PARAMETERS lc_str1, lc_str2
* R&R string compare equal
***************************
PRIVATE ll_ret
SET EXACT ON
* compare for equal, case-insensitive, full length
DO CASE
	CASE LEN(m->lc_str1) = 0
		ll_ret = LEN(TRIM(m->lc_str2)) = 0
	CASE LEN(m->lc_str2) = 0
		ll_ret = LEN(TRIM(m->lc_str1)) = 0
	OTHERWISE
		ll_ret = LOWER(m->lc_str1) = LOWER(m->lc_str2)
ENDCASE
SET EXACT OFF
RETURN m->ll_ret

***************************************
FUNCTION rr_st_le
PARAMETERS lc_str1, lc_str2
* R&R string compare less than or equal
***************************************
PRIVATE ll_ret
SET EXACT ON
* compare for less-than-or-equal, case-insensitive, full length
DO CASE
	CASE LEN(m->lc_str1) = 0
		ll_ret = .T.
	CASE LEN(m->lc_str2) = 0
		ll_ret = LEN(TRIM(m->lc_str1)) = 0
	OTHERWISE
		ll_ret = LOWER(m->lc_str1) <= LOWER(m->lc_str2)
ENDCASE
SET EXACT OFF
RETURN m->ll_ret

******************************
FUNCTION rr_st_lt
PARAMETERS lc_str1, lc_str2
* R&R string compare less than
******************************
PRIVATE ll_ret
SET EXACT ON
* compare for less-than, case-insensitive, full length
DO CASE
	CASE LEN(m->lc_str1) = 0
		ll_ret = LEN(TRIM(m->lc_str2)) > 0
	CASE LEN(m->lc_str2) = 0
		ll_ret = .F.
	OTHERWISE
		ll_ret = LOWER(m->lc_str1) < LOWER(m->lc_str2)
ENDCASE
SET EXACT OFF
RETURN m->ll_ret

***************************************
FUNCTION rr_word
PARAMETERS lc_str, ln_n, lc_bstr
* find nth word in character expression
***************************************
PRIVATE lc_ret, ll_inword, ll_done, ln_ptr, ln_wcnt, lc_chr
* default to a null string
lc_ret = ''
* if the input string isn't null and the desired word isn't zero
IF .NOT. (EMPTY(m->lc_str)) .AND. m->ln_n # 0
	* we're not within a word yet
	ll_inword = .F.
	* convert negative word number to positive number, e.g. -1 means
	* the last, or wdcount'th, word
	ln_n = IIF(m->ln_n > 0,ln_n,ln_n + wdcount(lc_str,lc_bstr) + 1)
	* we're not done yet
	ll_done = .F.
	* set the word count to zero
	ln_wcnt = 0
	* point to the first character
	ln_ptr = 1
	* process each character in the string
	DO WHILE m->ln_ptr <= LEN(lc_str) .AND. (.NOT.(m->ll_done))
		* store the current character
		lc_chr = SUBSTR(lc_str,m->ln_ptr,1)
		* if we're within a word
		IF m->ll_inword
			* if it's a word-break character
			IF m->lc_chr$lc_bstr
				* we're no longer within a word
				ll_inword = .F.
				* if that was the word we're looking for
				IF m->ln_n = m->ln_wcnt
					* we're done
					ll_done = .T.
				ENDIF
			* if it's not a word-break character
			ELSE
				* if this is the word we're looking for
				IF ln_n = m->ln_wcnt
					* append the current character to the result
					lc_ret = m->lc_ret + m->lc_chr
				ENDIF
			ENDIF
		* if we're not within a word
		ELSE
			* if it's not a word-break character
			IF .NOT.(m->lc_chr$m->lc_bstr)
				* we're now within a word (and it's the first character)
				ll_inword = .T.
				* increment the word count
				ln_wcnt = m->ln_wcnt + 1
				* if this is the word we're looking for
				IF m->ln_n = m->ln_wcnt
					* append the current character to the result
					lc_ret = m->lc_ret + m->lc_chr
				ENDIF
			ENDIF
		ENDIF
		* point to the next character
		ln_ptr = m->ln_ptr + 1
	ENDDO
ENDIF
* return the specified word
RETURN m->lc_ret